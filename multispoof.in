#!/bin/sh

# FIXME: Dynamic configuration should be done with getopt
REAL_IFACE="eth1"
TAP_IFACE="tap0"
# SCAN_IP and GATEWAY_IP needs to be in the same logical network
GATEWAY_IP="192.168.1.200"
NETMASK="18"
SCAN_IP="192.168.63.200"
SCAN_MAC="52:54:00:12:34:57"
GATEWAY_MAC="00:00:00:00:00:01"
# From my observations Windows SMB broadcasts are in max 12 minutes
# intervals, so setting MIN_AGE to 15 minutes would be safe bet.
MIN_AGE=60
MIN_TEST_AGE=120 # for conncheck
NATMAN_INTERVAL=5
CONNCHECK_INTERVAL=6
SCAN_INTERVAL=15

# Static configuration created by make
COMPONENTS_DIR=<COMPONENTS_DIR>
CACHE_FILE=<CACHE_DIR>/netdb.cache

# Internal variables
NDB_DIR=`mktemp -d multispoof.XXXXXXXX` || FAIL=1
if [ ! -z "$FAIL" ]
then
  echo "Couldn't create temporary directory."
  exit 1
fi
NDB_SOCKET="$NDB_DIR/socket"
MAIN_CHAIN="multispoof-main"
SUB_CHAIN="multispoof-sub"
TEST_CHAIN="multispoof-test"
TEST_SCRIPT="${COMPONENTS_DIR}/access-test"
PATH=$COMPONENTS_DIR:$PATH

function setup_nf_rules
{
  MULTISPOOF_SID=`ps -o sid= $$`

  iptables -t nat -N $MAIN_CHAIN 2> /dev/null
  iptables -t nat -N $SUB_CHAIN 2> /dev/null
  iptables -t nat -N $TEST_CHAIN 2> /dev/null
  iptables -t nat -F $MAIN_CHAIN
  iptables -t nat -F $SUB_CHAIN
  
  iptables -t nat -A $MAIN_CHAIN -o $TAP_IFACE -m owner \
    --sid-owner $MULTISPOOF_SID -j $TEST_CHAIN
  iptables -t nat -A $MAIN_CHAIN -j $SUB_CHAIN
  iptables -t nat -A $MAIN_CHAIN -j DROP
  iptables -t nat -D POSTROUTING -o $TAP_IFACE -j $MAIN_CHAIN \
     2>/dev/null
  iptables -t nat -I POSTROUTING -o $TAP_IFACE -j $MAIN_CHAIN
}

function clean_up_nf_rules
{
  iptables -t nat -D POSTROUTING -o $TAP_IFACE -j $MAIN_CHAIN \
        2> /dev/null
  iptables -t nat -F $MAIN_CHAIN
  iptables -t nat -F $SUB_CHAIN
  iptables -t nat -F $TEST_CHAIN
  iptables -t nat -X $MAIN_CHAIN
  iptables -t nat -X $SUB_CHAIN
  iptables -t nat -X $TEST_CHAIN
}

function clean_up
{
  trap 15
  # FIXME: restore configuration for $REAL_IFACE
  echo "multispoof: cleaning up"
  rm -rf $NDB_DIR
  clean_up_nf_rules
  kill -SIGTERM -$$
}

function spoof_pipeline
{
  local IFACE=$1
  rx $IFACE "ip and not ether broadcast" tapio | \
  cmac unspoof $MIN_AGE $NDB_SOCKET | tapio | \
  cmac spoof $MIN_AGE $NDB_SOCKET | tx $IFACE tapio
}

function scanarp_pipeline
{
  local IFACE=$1
  scanarp $NDB_SOCKET $SCAN_INTERVAL $SCAN_IP $SCAN_MAC | \
  tx $IFACE scanarp
}

function deta_pipeline
{
  local IFACE=$1
  rx $IFACE "ether broadcast or arp" deta | deta $NDB_SOCKET $MIN_AGE \
  | tx $IFACE deta
}

function register_mac
{
  local IFACE=$1
  local MAC=`ip link|grep -A 1 $IFACE | tail -n 1 | cut -d ' ' -f 6`
  if [ ! -z "$MAC" ]
  then
    ndbexec $NDB_SOCKET setvar defmac $MAC
  else
    echo "Problem getting mac address of interface $IFACE."
    kill $$
  fi
}

function set_variables
{
  local BANNED="$GATEWAY_IP:0.0.0.0:255.255.255.255"
  ndbexec $NDB_SOCKET setvar banned "$BANNED"
}

# FIXME: get address from real device
function setup_ifaces
{
  local REAL=$1
  local TAP=$2
  local CIDR="$SCAN_IP/$NETMASK"
  ip addr flush dev $REAL 2> /dev/null
  ip addr add $CIDR dev $TAP
  ip link set $TAP up
  arp -i $TAP -s $GATEWAY_IP $GATEWAY_MAC
  ip route add default via $GATEWAY_IP
}

echo "multispoof: PID $$"

trap clean_up 15 2

netdb $NDB_SOCKET $CACHE_FILE &
sleep 0.7 # netdb opening socket FIXME: find better solution
set_variables
spoof_pipeline $REAL_IFACE &
scanarp_pipeline $REAL_IFACE &
deta_pipeline $REAL_IFACE &
setup_nf_rules
natman $SUB_CHAIN $MIN_AGE $NATMAN_INTERVAL &
sleep 0.7 # tapio creating tap device FIXME: find better solution
register_mac $TAP_IFACE
setup_ifaces $REAL_IFACE $TAP_IFACE
conncheck $NDB_SOCKET $TEST_CHAIN $CONNCHECK_INTERVAL \
  $MIN_AGE $MIN_TEST_AGE $TEST_SCRIPT
# Wait for all children processes
wait
